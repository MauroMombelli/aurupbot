#!/bin/sh

              ####################################################
              #                                                  #
              #                  AUR Update Bot                  #
              #                                                  #
              #   Version: 1.1 (17/06/2015)                      #
              #   Author: Ian Brunelli <ian@brunelli.me>         #
              #   URL: https://github.com/ianbrunelli/aurupbot   #
              #                                                  #
              ####################################################

aur_check_update() {
  echo "==> Checking for pkgver() function"

  grep -e "^[[:space:]]*pkgver[[:space:]]*([[:space:]]*)[[:space:]]*{" -i PKGBUILD \
  > /dev/null ||
  { echo "No pkgver() function found." 2>&2
    return 71; }

  echo "==> Getting sources"

  OLD_PKGVER=$( grep -m 1 "^[[:space:]]*pkgver" PKGBUILD |
                cut -f 1 -d "=" --complement | tr -d \'\" )
  makepkg -do --skipchecksums > "$2/${1}_update.log" 2>&1 ||
  { error_report "$1" "Failed running initial makepkg." "$2/${1}_update.log" "critical"
    return 72; }
  NEW_PKGVER=$( grep -m 1 "^[[:space:]]*pkgver" PKGBUILD |
                cut -f 1 -d "=" --complement | tr -d \'\" )

  if [ "$OLD_PKGVER" == "$NEW_PKGVER" ]; then
    echo "$1 is up-to-date ($NEW_PKGVER)."
    return 70
  else
    echo "$1 is out-of-date ($OLD_PKGVER -> $NEW_PKGVER)."
  fi
}

build_package() {
  echo "==> Building package"
  makepkg > "$2/${1}_makepkg.log" 2>&1 &&
  { NEW_PKGVER=$( grep -m 1 -e "^[[:space:]]*pkgver" PKGBUILD |
                  cut -f 1 -d "=" --complement | tr -d \'\" )
    echo "Successfully built."; } ||
  { error_report "$1" "Build failed." "$2/${1}_makepkg.log" "critical"
    return 2; }
}

check_namcap() {
  echo "==> Checking package with namcap"

  PKGNAME=$( grep -m 1 -e "^[[:space:]]*pkgname" PKGBUILD |
             cut -f 1 -d "=" --complement | tr -d \'\"\(\) )

  for P in $PKG ${PKGNAME[@]/$PKG}; do
    namcap "$P-$NEW_PKGVER-*.pkg.tar.xz" >> "$2/${1}_namcap.log" 2>&1
    NAMCAP_E=$(( $NAMCAP_E + $( grep -c "$P E:" "$2/${1}_namcap.log" ) ))
    NAMCAP_W=$(( $NAMCAP_W + $( grep -c "$P W:" "$2/${1}_namcap.log" ) ))
  done

  if [ ${NAMCAP_E} -gt 0 ]; then
    error_report "$1" "Namcap returned $NAMCAP_E error(s) and $NAMCAP_W warning(s)." \
                 "$2/${1}_namcap.log" "critical"
    return 1
  elif [ ${NAMCAP_W} -gt 0 ]; then
    error_report "$1" "Namcap returned $NAMCAP_W warning(s)." \
                 "$2/${1}_namcap.log" "normal"
  fi
}

error_report() {
  echo "$2 See \"$3\" for details." 2>&2
  if [ "$ENABLE_NOTIFY" == true ]; then
    send_notification "$1" "$2 See \"$3\" for details." "$4"
  fi
  if [ "$EMAIL_REPORTS" == true ]; then
    send_email "$1" "$2" "$3"
  fi
}

generate_changelog() {
  unset CHANGELOG

  if [[ $1 =~ -bzr$ ]]; then
    echo "==> Creating changelog from Bazaar revisions"
    get_clone_dir "$1" bzr &&
    get_bzr_revs "$1"
  elif [[ $1 =~ -git$ ]]; then
    echo "==> Creating changelog from Git commits"
    get_git_dir "$1" "$2/${1}_update.log" &&
    get_git_commits "$1" "$2/${1}_update.log"
  elif [[ $1 =~ -hg$ ]]; then
    echo "==> Creating changelog from Mercurial revisions"
    get_clone_dir "$1" hg &&
    get_hg_revs "$1"
  elif [[ $1 =~ -svn$ ]]; then
    echo "==> Creating changelog from Subversion revisions"
    get_clone_dir "$1" svn &&
    get_svn_revs "$1"
  fi
}

get_clone_dir() {
  CLONE_DIR=$( grep -m 1 ${2}name PKGBUILD | cut -f 1 -d "=" --complement | tr -d \'\" )
  [ -d "$CLONE_DIR/.$2" ] ||
  CLONE_DIR=${1%-$2}
  [ -d "$CLONE_DIR/.$2" ] ||
  CLONE_DIR=$1
  [ -d "$CLONE_DIR/.$2" ] ||
  { echo "Couldn't find the $2 directory." 2>&2
    return 1; }
}

get_git_dir() {
  CLONE_DIR=$( sed -n "s/^[A-Z a-z]*'*\(\/.*\)$/\1/p" "$2" | sed "s/'\.\{3\}$//" )
  [ -d "$CLONE_DIR" ] &&
  { cd "$CLONE_DIR"; [ "$( git rev-parse --is-inside-git-dir )" == "true" ]; } ||
  CLONE_DIR=$( grep -m 1 gitname PKGBUILD | cut -f 1 -d "=" --complement | tr -d \'\" )
  [ -d "$CLONE_DIR" ] &&
  { cd "$CLONE_DIR"; [ "$( git rev-parse --is-inside-git-dir )" == "true" ]; } ||
  CLONE_DIR=${1%-git}
  [ -d "$CLONE_DIR" ] &&
  { cd "$CLONE_DIR"; [ "$( git rev-parse --is-inside-git-dir )" == "true" ]; } ||
  CLONE_DIR=$1
  [ -d "$CLONE_DIR" ] &&
  { cd "$CLONE_DIR"; [ "$( git rev-parse --is-inside-git-dir )" == "true" ]; } ||
  { echo "Couldn't find the Git directory." 2>&2
    return 1; }
}

get_bzr_revs() {
  FROM_REV=$(( ${OLD_PKGVER: 1} + 1 ))
  REV_LOG=$( cd "$CLONE_DIR" &&
             bzr log --log-format line -r $FROM_REV.. |
             sed -n "s/ .*[0-9]\{4\}-[0-9]\{2\}-[0-9]\{2\} / /p" ) &&
  CHANGELOG=$( echo -e "\n\nChangelog\n=========\n$REV_LOG" )
}

get_git_commits() {
  FROM_COMMIT=$( sed -n "s/^.*r[0-9][0-9]*.\([a-z0-9]*\).*$/\1/p" <<< "$OLD_PKGVER" )
  [ "$FROM_COMMIT" ] ||
  FROM_COMMIT=$( sed -n "/^From \//,/^[^ ]/p" "$1" | grep "^ " | grep " master " |
                 head -n 1 | sed -n "s/[ ]*\([A-Za-z0-9]*\)\.\..*/\1/p" )
  [ "$FROM_COMMIT" ] ||
  FROM_COMMIT=$( cd "$CLONE_DIR" &&
                 git rev-list `git describe --tags 2> /dev/null` 2> /dev/null |
                 head -n 1 )
  [ "$FROM_COMMIT" ] &&
  COMMIT_LOG=$( cd "$CLONE_DIR" &&
                { IS_GIT_DIR=$( git rev-parse --is-inside-git-dir 2> /dev/null )
                  if [ "$IS_GIT_DIR" == true ]; then
                    git log --pretty=format:"%s (%h)" ${FROM_COMMIT: -7}.. \
                    2> /dev/null
                  fi; } ) &&
  CHANGELOG=$( echo -e "\n\nChangelog\n=========\n$COMMIT_LOG" )
}

get_hg_revs() {
  FROM_REV=$(( $( cut -f 1 -d "." <<< "${OLD_PKGVER: 1}" ) + 1 ))
  REV_LOG=$( cd "$CLONE_DIR" &&
             hg log --template "{desc | firstline} ({node | short})\n" \
                    -r $FROM_REV.. | tac ) &&
  CHANGELOG=$( echo -e "\n\nChangelog\n=========\n$REV_LOG" )
}

get_svn_revs() {
  FROM_REV=$((${OLD_PKGVER: 1} + 1))
  REV_LOG=$( cd "$CLONE_DIR" &&
             svn log -r $FROM_REV:HEAD |
             sed "/^\s*$/d" |
             sed -n "/^r[0-9]* | .*$/{N;p}" |
             sed "s/^\(r[0-9]*\) | .*$/\1: /" |
             sed ":a;N;\$!ba;s/: \n/: /g" | tac ) &&
  CHANGELOG=$( echo -e "\n\nChangelog\n=========\n$REV_LOG" )
}

get_user_packages() {
  echo "==> Getting packages maintained by $1"

  USER_PKGS=$( curl -s "https://aur4.archlinux.org/rpc.php?type=msearch&arg=$1" |
               grep -Po '"Name":.*?[^\\],' |
               cut -f 4 -d \" )

  [ "$USER_PKGS" ] &&
  echo $( wc -w <<< "$USER_PKGS" ) "package(s) found:" $USER_PKGS ||
  echo "No package found." 2>&2
}

send_email() {
  echo "==> Sending email to $REPORT_EMAIL"

  hash mail 2> /dev/null &&
  { mail -a "$2" -s "The package $1 requires your attention" "$REPORT_EMAIL" <<< "$3" ||
    return 1; } ||
  echo "The command mail was not found." 2>&2
}

send_notification() {
  if [ "$3" == "critical" ]; then
    ICON="software-update-urgent-symbolic"
    TITLE="Error updating $1"
  elif [ "$3" == "normal" ]; then
    ICON="dialog-warning-symbolic"
    TITLE="Warning updating $1"
  else
    ICON="software-update-available-symbolic"
    TITLE="Successfully updated $1"
  fi

  hash notify-send 2> /dev/null &&
  { notify-send --urgency="$3" --icon="$ICON" --app-name="$SCRIPT_NAME" "$TITLE" "$2" ||
    return 1; } ||
  echo "The command notify-send was not found." 2>&2
}

update_aur() {
  echo "==> Pushing new version to AUR"

  { git add PKGBUILD .SRCINFO 2>&1 | tee "$2/${1}_git.log" &&
    git commit -m "Updated version ($OLD_PKGVER -> $NEW_PKGVER).$CHANGELOG" \
               --author="AUR Update Bot <$AUTHOR_EMAIL>" 2>& 1 |
    tee -a "$2/${1}_git.log" &&
    git push 2>&1 | tee -a "$2/${1}_git.log"
  } ||
  error_report "$1" "Pushing to AUR failed" "$2/${1}_git" "critical"
}

usage_guide() {
  cat << EOF
Usage: $SCRIPT_NAME [ OPTIONS ] [ PKGNAMES ]

Options:
  -d or --dir <path>	Save files in <path> instead of /tmp.
  --disable-push	Doesn't attempt to push the updated files to AUR.
  --email <email>	Send reports to <email>.
  -n or --notify	Use libnotify to send desktop notifications.
  -u or --user <user>	Check updates for all packages maintained by <user>.
  --config <file>	Source <file> for configuration.
  -h or --help		Print this message.

Configuration:
  The global configuration file can be found in /etc/aurupbotrc.
  You can have an user specific file in ~/.config/aurupbotrc.
EOF
}

SCRIPT_NAME=$( basename "$0" )
AUTHOR_EMAIL=$( git config user.email )

EMAIL_REPORTS=false
ENABLE_NOTIFY=false
ENABLE_PUSH=true
REPORT_EMAIL=$AUTHOR_EMAIL
REUSE_DIRS=false
SAVE_DIR="/tmp/$SCRIPT_NAME-$USER"

[ -f "/etc/aurupbotrc" ] &&
source "/etc/aurupbotrc"

[ -f "$HOME/.config/aurupbotrc" ] &&
source "$HOME/.config/aurupbotrc"

unset AUR_USERS PKGS

while [ $# -gt 0 ]; do
  if [ "$1" == "--config" ]; then
    [ "$2" ] && ! [[ $2 =~ ^- ]] &&
    { source "$( readlink -f "$2" )"
      shift 2; } ||
    { usage_guide
      exit 1; }
  elif [[ $1 =~ ^-(d|-dir)$ ]]; then
    shift
    SAVE_DIR=$( readlink -f "$1" )
    shift
  elif [ "$1" == "--email" ]; then
    [ "$2" ] && ! [[ $2 =~ ^- ]] &&
    { EMAIL_REPORTS=true
      REPORT_EMAIL="$2"
      shift 2; } ||
    { usage_guide
      exit 1; }
  elif [[ $1 =~ ^-(h|-help)$ ]]; then
    usage_guide
    exit 0
  elif [[ $1 =~ ^-(n|-notify)$ ]]; then
    ENABLE_NOTIFY=true
    shift
  elif [ "$1" == "--reuse-dirs" ]; then
    REUSE_DIRS=true
    shift
  elif [[ $1 =~ ^-(u|-user)$ ]]; then
    [ "$2" ] && ! [[ $2 =~ ^- ]] &&
    { AUR_USERS+=" $2"
      shift 2; } ||
    { usage_guide
      exit 1; }
  elif [ "$1" == "--disable-push" ]; then
    ENABLE_PUSH=false
    shift
  elif [[ $1 =~ ^- ]]; then
    echo "`basename $0`: unrecognized option '$1'" >&2
    usage_guide
    exit 1
  else
    PKGS+=" $1"
    shift
  fi
done

for AUR_USER in ${AUR_USERS}; do
  get_user_packages "$AUR_USER"
  PKGS+=" $USER_PKGS"
done

if [ $( wc -w <<< "$PKGS" ) -gt 0 ] &&
   [ "$SAVE_DIR" ]
then
  mkdir -p "${SAVE_DIR}" ||
  exit 2
  cd "${SAVE_DIR}"
elif [[ ! $AUR_USERS ]]; then
  usage_guide
fi

for PKG in ${PKGS}; do
  { if [ "$REUSE_DIRS" == true ] &&
       [ -f "${SAVE_DIR}/$PKG/PKGBUILD" ]
    then
      cd "${SAVE_DIR}/$PKG"
      echo "==> Updating the AUR repository for $PKG"
      git pull --quiet
      if [[ $( git diff origin/master ) ]]; then
        git diff origin/master > "${SAVE_DIR}/${PKG}_diff.log"
        error_report "$PKG" "Your local branch differs from remote. Push the changes before updating." \
                     "${SAVE_DIR}/${PKG}_diff.log" "critical"
        continue
      fi
    else
      [ -e "$PKG" ] &&
      { rm -rf "$PKG" ||
        exit 3; }
      echo "==> Cloning the AUR repository for $PKG"
      git clone "ssh://aur@aur4.archlinux.org/$PKG.git" "${SAVE_DIR}/$PKG" --quiet
    fi
  } &&
  { rm -f "${SAVE_DIR}/${PKG}"_*.log
    cd "${SAVE_DIR}/$PKG"
    [ -f PKGBUILD ] &&
    aur_check_update "$PKG" "$SAVE_DIR" &&
    build_package "$PKG" "$SAVE_DIR" &&
    check_namcap "$PKG" "$SAVE_DIR" &&
    { mksrcinfo &&
      if [ "$ENABLE_PUSH" == true ]; then
        generate_changelog "$PKG" "$SAVE_DIR"
        update_aur "$PKG" "$SAVE_DIR" &&
        if [ "$ENABLE_NOTIFY" == true ]; then
          send_notification "$PKG" "The package was updated and uploaded to AUR." "low"
        fi
      else
        echo -e "\nThe package was updated in \"$SAVE_DIR/$PKG\"."
        if [ "$ENABLE_NOTIFY" == true ]; then
          send_notification "$PKG" "The package was updated in \"$SAVE_DIR/$PKG\"." "low"
        fi
      fi
    }
  }
done
exit 0
